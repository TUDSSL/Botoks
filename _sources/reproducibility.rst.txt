Reproducibility
===============

In this section the steps required to reproduce the results presented in the
paper are explained.

Applications
------------

Bike speedometer
^^^^^^^^^^^^^^^^

1. Replace Botoks's solar cell with a magnetic energy harvester (one commonly
   found in inductive `bike lights
   <https://www.reelight.com/products/hub-lights>`_), and attach it to the fork
   of a bike, behind the wheel.

2. Connect one GPIO of Botoks to a logic analyzer to measure reboot periods and
   have a ground truth for the RPM of the wheel.

3. Connect Botoks to a debugger capable of debugging the MSP430 line of
   products.  *Set the target voltage to 2.2V* to avoid back-feeding.  Then
   power Botox using the auxiliary power connector on the PCB.  The voltage
   provided needs to be between 3.4 and 5V.

4. Program the ``bike-rpm-tx`` application using UniFlash:

   .. code:: bash

      $ ./flash.sh bin/bike-rpm-tx.out

5. Program another Botoks node to receive radio packets from the other node on
   the bike.  Have this latter node continuously powered, and record reboot
   periods contained in radio packets.

To produce the graph in the paper (Figure 9) convert reboot periods to RPM and
then to km/h (that depends on the radius of the wheel) of both the ground truth,
extracted with the logic analyzer, and the CHRT-measured results, collected by
the continuously-powered Botoks receiver.

Network synchronization
^^^^^^^^^^^^^^^^^^^^^^^

We have established a point-to-point link with two nodes powered by solar
energy, in one experiment, and radio-frequency energy, in another experiment.
The solar energy was generated by two independent light bulbs placed in two
closed boxes and collected by Botoks’s solar panel.  The radio-frequency energy
was provided by a Powercast transmitter `Powercast transmitter
<http://www.powercastco.com/wp-content/uploads/2016/11/User-Manual-TX-915-01-Rev-A-4.pdf>`_
and harvested by a `Powercast receiver
<http://www.powercastco.com/wp-content/uploads/2016/11/p2110-evb1.pdf>`_
connected to Botoks’s power supply (in place of the solar cell).  In the
application, the transmitting node would wake up to send one packet of data,
using its buffered energy, eventually incurring a power failure, proceeding then
to harvest energy and finally recharge and wake up again.  Similarly, the
receiving node would wake up and start listening until receiving a packet, or
until a power outage.

1. Connect one Botoks to a debugger capable of debugging the MSP430 line of
   products.  *Set the target voltage to 2.2V* to avoid back-feeding.  Then
   power Botox using the auxiliary power connector on the PCB.  The voltage
   provided needs to be between 3.4 and 5V.

2. Program the ``intermittent-tx`` application using UniFlash:

   .. code:: bash

      $ ./flash.sh bin/intermittent-tx.out

3. Program the second Botoks with the ``intermittent-rx`` application:

   .. code:: bash

      $ ./flash.sh bin/intermittent-rx.out

4. Connect both nodes to a logic analyzer to record sent and received packets.

5. For the solar energy experiment, place each node in a box that can filter out
   external light, and place a controllable light bulb in each of the box.  Then
   turn on the light bulbs to start the experiment.

6. After 10 minutes, turn off the lights to conclude the experiment.

Use the logic analyzer data to compute the ratio between received and sent
packets and produce the graphs as in the paper (Figure 10).

CHRT Accuracy
-------------

In this procedure we assume the CHRT already has been calibrated. Please refer to
the CHRT section for instructions on how to calibrate the CHRT.

In order to verify the results presented about the accuracy of the CHRT the following steps are executed:

1. Connect Botoks to a debugger capable of debugging the MSP430 line of
   products.  *Set the target voltage to 2.2V* to avoid back-feeding.  Then
   power Botox using the auxiliary power connector on the PCB.  The voltage
   provided needs to be between 3.4 and 5V.

2.  Program the `calib-accuracy` application using Uniflash.

  .. code:: bash

     $ ./flash.sh  bin/calib-accuracy-t0.out

3.  Monitor the output.

  .. code:: bash

     $ picocom /dev/ttyACM1 -b 19200 --imap lfcrlf

4.  Repeat this process 10 times (go back to step 2).
5.  In previous steps the accuracy of tier 0 was measured. Now this process is
    repeated for every other tier. Change `t0` to `t1`, `t2` or `t3` in the bash call
    to program the device.

With the measurements completed, we processed the data as follows:

- Average the reported time for each time-step of the 10 runs for tier 0 and tier 3.
  These results are presented in figure 7a and 7b.
- For figure 7c and 7d, first the error is computed by deducting the expected time from the measurement.
  Next all of the computed errors for a tier (so over the whole timing range and 10 executions)
  are binned into -2, -1, 0, 1, 2 bins and from this the percentages are computed
  that are shown in figure 7c and 7d.
